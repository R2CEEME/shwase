import os
import time
import json
import threading
import traceback
import requests
import joblib
import numpy as np
import pandas as pd
import tensorflow as tf
import talib
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
import xgboost as xgb
from prophet import Prophet  # Prophet k√ºt√ºphanesi (pip install prophet)
from websocket import WebSocketApp  # websocket-client (pip install websocket-client)

# Genel Ayarlar
BINANCE_API_URL = 'https://api.binance.com/api/v3/klines'
CRYPTOS = [
    'BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'AVAXUSDT', 'XRPUSDT',
    'BNBUSDT', 'LTCUSDT', 'DOTUSDT'
]
TIME_STEPS = 60
PREDICTION_HORIZON = 3
INTERVAL = '15m'  # Y√ºksek frekanslƒ± veri (WebSocket ve REST i√ßin kullanƒ±lmaya devam ediyor)
LOOK_BACK_DAYS = 90  # Daha uzun tarihsel veri

# Telegram Ayarlarƒ±
TELEGRAM_TOKEN = ""
TELEGRAM_CHAT_ID = ""
TELEGRAM_API_URL = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"

# Cryptopanic API Ayarlarƒ± (Haber/sentiment analizi)
CRYPTOPANIC_API_KEY = ""
CRYPTOPANIC_API_URL = "https://cryptopanic.com/api/v1/posts/"

# Karar Parametreleri
CONFIDENCE_THRESHOLD = 0.0  # Sinyal g√ºven e≈üik deƒüeri
MIN_VOLUME_PERCENTILE = 30
BACKTEST_DAYS = 14  # Geri test i√ßin g√ºn sayƒ±sƒ±

# WebSocket Ayarlarƒ±
BINANCE_WS_URL = "wss://stream.binance.com:9443/ws"


class EnhancedCryptoAnalyzer:
    def __init__(self):
        self.lstm_models = {}      # LSTM modelleri i√ßin
        self.prophet_models = {}   # Prophet modelleri i√ßin
        self.xgb_models = {}       # XGBoost modelleri i√ßin
        self.scalers = {}          # Fiyat √∂l√ßekleyicileri (LSTM ve XGB i√ßin)
        self.feature_scalers = {}  # √ñzellik √∂l√ßekleyicileri (LSTM ve XGB i√ßin)
        self.last_signals = {}
        self.accuracy_metrics = {}
        # WebSocket verileri i√ßin g√ºncel data deposu
        self.ws_data = {crypto: None for crypto in CRYPTOS}
        tf.config.run_functions_eagerly(False)
        self.load_or_train_models()
        self.send_telegram_message("üöÄ *Atlantis Ba≈ülatƒ±ldƒ±.* üöÄ\nSinyaller otomatik olarak g√∂nderilecektir.")
        # Program kapanƒ±≈üƒ±nda Telegram mesajƒ± g√∂nder
        import atexit
        atexit.register(self.send_closing_message)
        # WebSocket baƒülantƒ±sƒ±nƒ± ba≈ülat
        self.start_websocket()

    def send_telegram_message(self, message):
        try:
            payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message, 'parse_mode': 'Markdown'}
            requests.post(TELEGRAM_API_URL, data=payload)
            print(f"üì§ Mesaj g√∂nderildi -> {message}")
        except Exception as e:
            print(f"‚ùå Telegram hatasƒ±: {e}")

    def send_closing_message(self):
        self.send_telegram_message("‚ö†Ô∏è *Atlantis Durduruldu.* ‚ö†Ô∏è")

    def load_or_train_models(self):
        for crypto in CRYPTOS:
            try:
                # Dosya isimleri i√ßin ortak isimlendirme
                lstm_model_path = f'{crypto}_lstm_model.keras'
                scaler_path = f'{crypto}_price_scaler.pkl'
                feature_scaler_path = f'{crypto}_feature_scaler.pkl'
                prophet_model_path = f'{crypto}_prophet_model.pkl'
                xgb_model_path = f'{crypto}_xgb_model.pkl'

                # LSTM modeli
                if os.path.exists(lstm_model_path) and os.path.exists(scaler_path) and os.path.exists(feature_scaler_path):
                    self.lstm_models[crypto] = tf.keras.models.load_model(lstm_model_path)
                    self.scalers[crypto] = joblib.load(scaler_path)
                    self.feature_scalers[crypto] = joblib.load(feature_scaler_path)
                    print(f"‚úÖ {crypto} LSTM modeli ve √∂l√ßekleyiciler y√ºklendi.")
                else:
                    print(f"üîÑ {crypto} i√ßin LSTM modeli eƒüitiliyor...")
                    self.train_lstm_model(crypto)

                # Prophet modeli
                if os.path.exists(prophet_model_path):
                    self.prophet_models[crypto] = joblib.load(prophet_model_path)
                    print(f"‚úÖ {crypto} Prophet modeli y√ºklendi.")
                else:
                    print(f"üîÑ {crypto} i√ßin Prophet modeli eƒüitiliyor...")
                    self.train_prophet_model(crypto)

                # XGBoost modeli
                if os.path.exists(xgb_model_path):
                    self.xgb_models[crypto] = joblib.load(xgb_model_path)
                    print(f"‚úÖ {crypto} XGBoost modeli y√ºklendi.")
                else:
                    print(f"üîÑ {crypto} i√ßin XGBoost modeli eƒüitiliyor...")
                    self.train_xgb_model(crypto)

                # Model performansƒ±nƒ± deƒüerlendir (isteƒüe baƒülƒ±)
                self.evaluate_model(crypto)

            except Exception as e:
                print(f"‚ùå {crypto} model y√ºkleme hatasƒ±: {e}")
                traceback.print_exc()

    def get_historical_data(self, crypto, limit=1000, interval=INTERVAL):
        try:
            days_ago = int(limit / (24 * (60/15))) + 5  # 15 dakikalƒ±k veri: 4 per saat
            start_time = int((datetime.now() - timedelta(days=days_ago)).timestamp() * 1000)
            all_data = []
            current_start = start_time

            while True:
                params = {
                    'symbol': crypto,
                    'interval': interval,
                    'limit': 1000,
                    'startTime': current_start
                }
                response = requests.get(BINANCE_API_URL, params=params)
                response.raise_for_status()
                data = response.json()
                if not data:
                    break
                all_data.extend(data)
                if len(data) < 1000:
                    break
                current_start = data[-1][0] + 1

            if not all_data:
                print(f"‚ö†Ô∏è {crypto} i√ßin veri bulunamadƒ±.")
                return None

            df = pd.DataFrame(all_data, columns=[
                'timestamp', 'open', 'high', 'low', 'close', 'volume',
                'close_time', 'quote_volume', 'trades',
                'taker_buy_base', 'taker_buy_quote', 'ignore'
            ])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = df[col].astype(float)
            self.add_technical_indicators(df)
            return df
        except Exception as e:
            print(f"üî¥ {crypto} veri √ßekme hatasƒ±: {e}")
            traceback.print_exc()
            return None

    def add_technical_indicators(self, df):
        df['sma_7'] = talib.SMA(df['close'].values, timeperiod=7)
        df['sma_25'] = talib.SMA(df['close'].values, timeperiod=25)
        df['sma_99'] = talib.SMA(df['close'].values, timeperiod=99)
        df['trend'] = np.where(df['sma_7'] > df['sma_25'], 1, -1)
        df['rsi'] = talib.RSI(df['close'].values, timeperiod=14)
        df['stoch_k'], df['stoch_d'] = talib.STOCH(df['high'].values, df['low'].values, df['close'].values)
        df['macd'], df['macd_signal'], df['macd_hist'] = talib.MACD(df['close'].values)
        df['atr'] = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=14)
        df['bollinger_upper'], df['bollinger_mid'], df['bollinger_lower'] = talib.BBANDS(df['close'].values)
        df['obv'] = talib.OBV(df['close'].values, df['volume'].values)
        df['mfi'] = talib.MFI(df['high'].values, df['low'].values, df['close'].values, df['volume'].values)
        df['price_change_1h'] = df['close'].pct_change(4)  # 15m veri: 4 adƒ±m = 1 saat
        df['price_change_4h'] = df['close'].pct_change(16)
        df['price_change_24h'] = df['close'].pct_change(96)
        df['volume_change_1h'] = df['volume'].pct_change(4)
        df['volume_change_4h'] = df['volume'].pct_change(16)
        df['volume_change_24h'] = df['volume'].pct_change(96)
        df.dropna(inplace=True)
        return df

    def prepare_features(self, df):
        features = df[['close', 'volume', 'sma_7', 'sma_25', 'sma_99',
                       'rsi', 'stoch_k', 'stoch_d', 'macd', 'macd_signal', 'macd_hist',
                       'atr', 'bollinger_upper', 'bollinger_lower',
                       'obv', 'mfi', 'price_change_1h', 'price_change_4h', 'price_change_24h',
                       'volume_change_1h', 'volume_change_4h', 'volume_change_24h']].values
        target = df['close'].values
        return features, target

    def create_dataset(self, features, target):
        X, y = [], []
        for i in range(len(features) - TIME_STEPS - PREDICTION_HORIZON):
            X.append(features[i:i + TIME_STEPS])
            future_prices = target[i + TIME_STEPS:i + TIME_STEPS + PREDICTION_HORIZON]
            current_price = target[i + TIME_STEPS - 1]
            price_changes = [(fp / current_price) - 1 for fp in future_prices]
            y.append(price_changes)
        return np.array(X), np.array(y)

    def train_lstm_model(self, crypto):
        try:
            data = self.get_historical_data(crypto, limit=LOOK_BACK_DAYS * (24 * 4))
            if data is None or len(data) < 500:
                print(f"‚ùå Yetersiz veri: {crypto}")
                return
            features, target = self.prepare_features(data)
            feature_scaler = MinMaxScaler()
            scaled_features = feature_scaler.fit_transform(features)
            price_scaler = MinMaxScaler()
            price_scaler.fit(target.reshape(-1, 1))
            X, y = self.create_dataset(scaled_features, target)
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
            model = tf.keras.Sequential([
                tf.keras.layers.Input(shape=(TIME_STEPS, features.shape[1])),
                tf.keras.layers.LSTM(128, return_sequences=True),
                tf.keras.layers.Dropout(0.3),
                tf.keras.layers.LSTM(64, return_sequences=False),
                tf.keras.layers.Dropout(0.2),
                tf.keras.layers.Dense(32, activation='relu'),
                tf.keras.layers.Dense(PREDICTION_HORIZON)
            ])
            optimizer = tf.keras.optimizers.Adam(learning_rate=0.0003)
            model.compile(optimizer=optimizer, loss='huber')
            early_stop = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=15, restore_best_weights=True)
            reduce_lr = tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, min_lr=0.00001)
            model.fit(X_train, y_train, epochs=200, batch_size=32, validation_data=(X_test, y_test),
                      callbacks=[early_stop, reduce_lr], verbose=1)
            model.save(f'{crypto}_lstm_model.keras')
            joblib.dump(price_scaler, f'{crypto}_price_scaler.pkl')
            joblib.dump(feature_scaler, f'{crypto}_feature_scaler.pkl')
            self.lstm_models[crypto] = model
            self.scalers[crypto] = price_scaler
            self.feature_scalers[crypto] = feature_scaler
            test_loss = model.evaluate(X_test, y_test, verbose=0)
            print(f"‚úÖ {crypto} LSTM modeli eƒüitildi. Test loss: {test_loss:.4f}")
        except Exception as e:
            print(f"‚ùå {crypto} LSTM eƒüitim hatasƒ±: {e}")
            traceback.print_exc()

    def train_prophet_model(self, crypto):
        try:
            data = self.get_historical_data(crypto, limit=LOOK_BACK_DAYS * (24 * 4))
            if data is None or data.empty:
                print(f"‚ùå {crypto} i√ßin yeterli veri yok (Prophet).")
                return
            # Prophet i√ßin df: ds, y (kapanƒ±≈ü fiyatƒ±)
            prophet_df = data[['timestamp', 'close']].rename(columns={'timestamp': 'ds', 'close': 'y'})
            model = Prophet(daily_seasonality=True)
            model.fit(prophet_df)
            joblib.dump(model, f'{crypto}_prophet_model.pkl')
            self.prophet_models[crypto] = model
            print(f"‚úÖ {crypto} Prophet modeli eƒüitildi.")
        except Exception as e:
            print(f"‚ùå {crypto} Prophet eƒüitim hatasƒ±: {e}")
            traceback.print_exc()

    def train_xgb_model(self, crypto):
        try:
            data = self.get_historical_data(crypto, limit=LOOK_BACK_DAYS * (24 * 4))
            if data is None or len(data) < 500:
                print(f"‚ùå Yetersiz veri: {crypto} (XGBoost)")
                return
            features, target = self.prepare_features(data)
            feature_scaler = MinMaxScaler()
            scaled_features = feature_scaler.fit_transform(features)
            # XGBoost hedef olarak kapanƒ±≈ü fiyatƒ±nƒ± kullanƒ±yoruz
            X = scaled_features
            y = target
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
            dtrain = xgb.DMatrix(X_train, label=y_train)
            dtest = xgb.DMatrix(X_test, label=y_test)
            params = {'objective': 'reg:squarederror', 'learning_rate': 0.05, 'max_depth': 5}
            xgb_model = xgb.train(params, dtrain, num_boost_round=200, evals=[(dtest, 'eval')], early_stopping_rounds=10, verbose_eval=False)
            joblib.dump(xgb_model, f'{crypto}_xgb_model.pkl')
            joblib.dump(feature_scaler, f'{crypto}_feature_scaler.pkl')  # Aynƒ± √∂l√ßekleyici kullanƒ±labilir
            self.xgb_models[crypto] = xgb_model
            self.feature_scalers[crypto] = feature_scaler
            print(f"‚úÖ {crypto} XGBoost modeli eƒüitildi.")
        except Exception as e:
            print(f"‚ùå {crypto} XGBoost eƒüitim hatasƒ±: {e}")
            traceback.print_exc()

    def evaluate_model(self, crypto):
        try:
            data = self.get_historical_data(crypto, limit=BACKTEST_DAYS * (24 * 4))
            if data is None or len(data) < TIME_STEPS + PREDICTION_HORIZON:
                print(f"‚ö†Ô∏è {crypto} i√ßin yeterli geri test verisi yok.")
                return
            total_signals = 0
            correct_signals = 0
            for i in range(TIME_STEPS, len(data) - PREDICTION_HORIZON):
                slice_data = data.iloc[i - TIME_STEPS:i]
                features, _ = self.prepare_features(slice_data)
                scaled_features = self.feature_scalers[crypto].transform(features)
                input_data = scaled_features.reshape(1, TIME_STEPS, features.shape[1])
                lstm_pred = self.lstm_models[crypto].predict(input_data, verbose=0)[0]
                current_price = data.iloc[i - 1]['close']
                future_prices = data.iloc[i:i + PREDICTION_HORIZON]['close'].values
                lstm_future = [current_price * (1 + change) for change in lstm_pred]
                # Prophet tahmini: Son tarihi alƒ±p tahmin ettir
                prophet_model = self.prophet_models[crypto]
                last_date = data['timestamp'].max()
                future_dates = pd.date_range(last_date, periods=PREDICTION_HORIZON+1, freq='15min')[1:]
                prophet_df = pd.DataFrame({'ds': future_dates})
                prophet_forecast = prophet_model.predict(prophet_df)['yhat'].values
                # XGBoost tahmini
                xgb_features = scaled_features[-1].reshape(1, -1)
                dmatrix = xgb.DMatrix(xgb_features)
                xgb_pred = self.xgb_models[crypto].predict(dmatrix)
                # Ensemble: Basit ortalama
                ensemble_future = np.mean([lstm_future, prophet_forecast, [xgb_pred[0]] * PREDICTION_HORIZON], axis=0)
                avg_predicted = np.mean(ensemble_future)
                position = 'HOLD'
                confidence = abs(avg_predicted - current_price) / current_price
                if avg_predicted > current_price * 1.005 and confidence > CONFIDENCE_THRESHOLD:
                    position = 'BUY'
                elif avg_predicted < current_price * 0.995 and confidence > CONFIDENCE_THRESHOLD:
                    position = 'SELL'
                if position != 'HOLD':
                    total_signals += 1
                    actual_result = future_prices[-1]
                    if (position == 'BUY' and actual_result > current_price * 1.005) or \
                       (position == 'SELL' and actual_result < current_price * 0.995):
                        correct_signals += 1
            accuracy = correct_signals / total_signals if total_signals > 0 else 0
            self.accuracy_metrics[crypto] = {
                'total_signals': total_signals,
                'correct_signals': correct_signals,
                'accuracy': accuracy,
                'timestamp': datetime.now()
            }
            print(f"üìä {crypto} geri test sonucu: {accuracy:.2%} ({correct_signals}/{total_signals})")
        except Exception as e:
            print(f"‚ùå {crypto} deƒüerlendirme hatasƒ±: {e}")
            traceback.print_exc()

    def get_global_market_state(self):
        try:
            btc_data = self.get_historical_data('BTCUSDT', limit=48)
            if btc_data is None:
                return 'NEUTRAL'
            sma_short = btc_data['sma_7'].values[-1]
            sma_long = btc_data['sma_25'].values[-1]
            last_day_change = btc_data['price_change_24h'].values[-1]
            rsi = btc_data['rsi'].values[-1]
            if sma_short > sma_long and last_day_change > 0.01 and rsi > 50:
                return 'BULLISH'
            elif sma_short < sma_long and last_day_change < -0.01 and rsi < 50:
                return 'BEARISH'
            else:
                return 'NEUTRAL'
        except Exception as e:
            print(f"‚ùå Piyasa analizi hatasƒ±: {e}")
            return 'NEUTRAL'

    def get_sentiment(self, crypto):
        """
        Cryptopanic API'sini kullanarak haber duyarlƒ±lƒ±ƒüƒ± sorgusu.
        Not: API anahtarƒ±nƒ± ve parametreleri kendinize g√∂re d√ºzenleyin.
        """
        try:
            params = {
                'auth_token': CRYPTOPANIC_API_KEY,
                'currencies': crypto.replace("USDT", ""),
                'public': 'true'
            }
            response = requests.get(CRYPTOPANIC_API_URL, params=params)
            response.raise_for_status()
            data = response.json()
            # Basit skor: olumlu - olumsuz haber sayƒ±sƒ±
            positive = sum(1 for post in data.get('results', []) if post.get('kind') == 'news' and post.get('currencies'))
            negative = sum(1 for post in data.get('results', []) if post.get('kind') == 'media' and post.get('currencies'))
            sentiment_score = positive - negative
            return sentiment_score
        except Exception as e:
            print(f"‚ùå {crypto} sentiment analizi hatasƒ±: {e}")
            return 0

    def predict(self, crypto):
        try:
            # Model kontrol√º: Eksik model varsa bu coin atlanƒ±yor.
            if crypto not in self.lstm_models or crypto not in self.prophet_models or crypto not in self.xgb_models:
                print(f"‚ùå {crypto} modeli eksik, atlanƒ±yor.")
                return None

            # √ñncelikle WebSocket'ten gelen g√ºncel veri varsa onu kullan, yoksa REST API ile √ßek
            data = self.ws_data.get(crypto)
            if data is None:
                data = self.get_historical_data(crypto, limit=TIME_STEPS + 24)
            if data is None or len(data) < TIME_STEPS:
                print(f"‚ö†Ô∏è {crypto} i√ßin yeterli veri yok.")
                return None

            current_data = data.iloc[-TIME_STEPS:]
            features, _ = self.prepare_features(current_data)
            scaled_features = self.feature_scalers[crypto].transform(features)
            input_data = scaled_features.reshape(1, TIME_STEPS, features.shape[1])
            lstm_pred = self.lstm_models[crypto].predict(input_data, verbose=0)[0]
            current_price = data['close'].values[-1]
            lstm_future = [current_price * (1 + change) for change in lstm_pred]

            # Prophet tahmini
            prophet_model = self.prophet_models[crypto]
            last_date = data['timestamp'].max()
            # FutureWarning uyarƒ±sƒ±nƒ± √∂nlemek i√ßin '15min' kullanƒ±lƒ±yor.
            future_dates = pd.date_range(last_date, periods=PREDICTION_HORIZON+1, freq='15min')[1:]
            prophet_df = pd.DataFrame({'ds': future_dates})
            prophet_forecast = prophet_model.predict(prophet_df)['yhat'].values

            # XGBoost tahmini
            xgb_features = scaled_features[-1].reshape(1, -1)
            dmatrix = xgb.DMatrix(xgb_features)
            xgb_pred = self.xgb_models[crypto].predict(dmatrix)

            # Ensemble: Basit ortalama
            ensemble_future = np.mean([lstm_future, prophet_forecast, [xgb_pred[0]] * PREDICTION_HORIZON], axis=0)
            avg_predicted_price = np.mean(ensemble_future)
            market_state = self.get_global_market_state()
            current_volume = data['volume'].values[-1]
            volume_percentile = np.percentile(data['volume'].values, MIN_VOLUME_PERCENTILE)
            sufficient_volume = current_volume >= volume_percentile
            rsi = data['rsi'].values[-1]
            macd_hist = data['macd_hist'].values[-1]
            stoch_k = data['stoch_k'].values[-1]
            stoch_d = data['stoch_d'].values[-1]
            # Temel pozisyon kurallarƒ±
            position = 'HOLD'
            confidence = abs(avg_predicted_price - current_price) / current_price * 100  # % bazƒ±nda
            if avg_predicted_price > current_price * 1.003 and confidence > CONFIDENCE_THRESHOLD:
                position = 'BUY'
            elif avg_predicted_price < current_price * 0.997 and confidence > CONFIDENCE_THRESHOLD:
                position = 'SELL'
            # Sentiment analizi: Negatif duygu BUY'u, pozitif duygu SELL'i filtreler
            sentiment = self.get_sentiment(crypto)
            if sentiment < 0 and position == 'BUY':
                position = 'HOLD'
            elif sentiment > 0 and position == 'SELL':
                position = 'HOLD'
            # Ekstra g√ºven ayarlamasƒ±
            if position in ['BUY', 'SELL']:
                confidence += min(0.2, abs(rsi - 50) / 100) * 100  # % ekleme
            if crypto in self.accuracy_metrics:
                accuracy = self.accuracy_metrics[crypto]['accuracy']
                if accuracy < 0.5:
                    confidence *= accuracy
            # TP/SL hesaplamasƒ±: %2 hedef, %1 stop
            if position == 'BUY':
                tp = current_price * (1 + 0.02)
                sl = current_price * (1 - 0.01)
            elif position == 'SELL':
                tp = current_price * (1 - 0.02)
                sl = current_price * (1 + 0.01)
            else:
                tp = current_price
                sl = current_price

            return {
                'crypto': crypto,
                'price': current_price,
                'prediction': ensemble_future.tolist(),
                'market_state': market_state,
                'technical': {
                    'rsi': round(rsi, 1),
                    'macd_hist': round(macd_hist, 4),
                    'stoch_k': round(stoch_k, 1),
                    'stoch_d': round(stoch_d, 1),
                    'volume': current_volume
                },
                'sentiment': sentiment,
                'decision': {
                    'position': position,
                    'confidence': round(confidence, 3),
                    'tp': round(tp, 2),
                    'sl': round(sl, 2)
                }
            }
        except Exception as e:
            print(f"üî¥ {crypto} tahmin hatasƒ±: {e}")
            traceback.print_exc()
            return None

    def should_send_signal(self, result):
        crypto = result['crypto']
        position = result['decision']['position']
        now = time.time()
        last = self.last_signals.get(crypto, (0, ''))
        if last[1] == position and now - last[0] < 14400:  # Son 4 saatte aynƒ± sinyal
            return False
        self.last_signals[crypto] = (now, position)
        return True

    def format_message(self, result):
        return (
            f"üìä *{result['crypto']}* Analizi\n"
            f"üí∞ Fiyat: ${result['price']:.2f}\n"
            f"üåç Piyasa: {result['market_state']}\n"
            f"üß≠ Pozisyon: {result['decision']['position']}\n"
            f"üìà G√ºven: %{result['decision']['confidence'] * 1:.1f}\n"
            f"üì∞ Sentiment: {result['sentiment']}\n"
            f"üéØ TP: ${result['decision']['tp']}\n"
            f"üõë SL: ${result['decision']['sl']}"
        )

    def analyze_and_notify(self):
        market_state = self.get_global_market_state()
        print(f"üåç Genel piyasa durumu: {market_state}")
        for crypto in CRYPTOS:
            result = self.predict(crypto)
            if result:
                print(f"{crypto}: Pozisyon={result['decision']['position']}, G√ºven={result['decision']['confidence']}")
                if self.should_send_signal(result):
                    message = self.format_message(result)
                    self.send_telegram_message(message)
        current_hour = datetime.now().hour
        if current_hour == 0:
            for crypto in CRYPTOS:
                self.evaluate_model(crypto)

    def start_websocket(self):
        def on_message(ws, message):
            try:
                data = json.loads(message)
                stream = data.get('s')
                if stream in CRYPTOS:
                    # Gelen websocket verisini dataframe formatƒ±na uygun hale getir
                    kline = data.get('k', {})
                    df = pd.DataFrame([{
                        'timestamp': pd.to_datetime(kline.get('t'), unit='ms'),
                        'open': float(kline.get('o')),
                        'high': float(kline.get('h')),
                        'low': float(kline.get('l')),
                        'close': float(kline.get('c')),
                        'volume': float(kline.get('v'))
                    }])
                    df = self.add_technical_indicators(df)
                    # Websocket verisini g√ºncel data olarak sakla
                    self.ws_data[stream] = df
            except Exception as e:
                print(f"WebSocket mesaj i≈üleme hatasƒ±: {e}")

        def on_error(ws, error):
            print(f"WebSocket hatasƒ±: {error}")

        def on_close(ws):
            print("WebSocket kapandƒ±, yeniden baƒülanƒ±lƒ±yor...")
            time.sleep(5)
            self.start_websocket()

        def on_open(ws):
            print("WebSocket baƒülantƒ±sƒ± a√ßƒ±ldƒ±.")
            # Her kripto i√ßin abone ol
            for crypto in CRYPTOS:
                params = {
                    "method": "SUBSCRIBE",
                    "params": [f"{crypto.lower()}@kline_{INTERVAL}"],
                    "id": 1
                }
                ws.send(json.dumps(params))

        def run_ws():
            ws = WebSocketApp(BINANCE_WS_URL,
                              on_open=on_open,
                              on_message=on_message,
                              on_error=on_error,
                              on_close=on_close)
            ws.run_forever()

        ws_thread = threading.Thread(target=run_ws, daemon=True)
        ws_thread.start()


if __name__ == "__main__":
    print("üöÄ Geli≈ütirilmi≈ü HybridCryptoAnalyzer ba≈ülatƒ±lƒ±yor...")
    bot = EnhancedCryptoAnalyzer()
    print("üîç Kripto paralarƒ±n ba≈ülangƒ±√ß deƒüerlendirmesi yapƒ±lƒ±yor...")
    for crypto in CRYPTOS:
        bot.evaluate_model(crypto)
    for crypto in CRYPTOS:
        result = bot.predict(crypto)
        if result and result['decision']['position'] != 'HOLD' and result['decision']['confidence'] > CONFIDENCE_THRESHOLD:
            message = "[Ba≈ülangƒ±√ß Sinyali] " + bot.format_message(result)
            bot.send_telegram_message(message)
            bot.last_signals[crypto] = (time.time(), result['decision']['position'])
    print("‚úÖ Ba≈ülangƒ±√ß deƒüerlendirmesi tamamlandƒ±, d√ºzenli analiz d√∂ng√ºs√º ba≈ülƒ±yor...")
    while True:
        try:
            print(f"‚è∞ Analiz Ba≈üladƒ±: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}")
            bot.analyze_and_notify()
            print("‚úÖ Analiz tamamlandƒ±. 30 dk sonra tekrar kontrol ediliyor.\n")
            time.sleep(1800)  # 30 dakika bekle
        except Exception as e:
            print(f"üî¥ D√∂ng√º hatasƒ±: {e}")
            traceback.print_exc()
            time.sleep(300)
